---
title: Basic NumPy Guide Working with 2D and 3D Data
date: 2025-6-30
tags: ['python', 'numpy', 'machine learning', 'AI', ]
summary: Bài viết này cung cấp hướng dẫn cơ bản về NumPy, tập trung vào cách biểu diễn và xử lý dữ liệu hai chiều (2D) và ba chiều (3D). Bạn sẽ tìm hiểu cách tạo, truy cập và thay đổi hình dạng mảng NumPy, cũng như cách sử dụng chúng để thao tác dữ liệu nhiều chiều một cách hiệu quả trong Python.
---

import Twemoji from './components/ui/Twemoji';

## Tại sao cần học NumPy?

Mặc dù Python với kiểu dữ liệu `list` có thể xử lý nhiều tác vụ khác nhau, nhưng khi nói đến tính toán khoa học và phân tích dữ liệu, đặc biệt là với các tập dữ liệu lớn, `list` bộc lộ nhiều hạn chế. Vì thế **NumPy** (Numerical Python) được sinh ra để giải quyết nhiều vấn đề mà Python cơ bản không làm được.

### Hiệu suất vượt trội cho tính toán

Python `list` là một cấu trúc dữ liệu rất linh hoạt, có thể chứa nhiều kiểu dữ liệu khác nhau (số, chuỗi, đối tượng khác). Tuy nhiên, chính sự linh hoạt này lại khiến nó không hiệu quả cho các phép toán số học trên diện rộng.

  * **List**: Các phép toán trên `list` thường được thực hiện thông qua các vòng lặp `for`. Khi làm việc với các vector hay ma trận lớn, việc lặp qua từng phần tử để tính toán trở nên rất chậm chạp.
  * **NumPy Array**: NumPy cung cấp cấu trúc dữ liệu `ndarray` (n-dimensional array). Các phần tử trong một array của NumPy phải có cùng kiểu dữ liệu. Điều này cho phép NumPy thực thi các phép toán được tối ưu hóa ở tầng C/Fortran, nhanh hơn gấp nhiều lần so với Python thuần túy.

Ví dụ, hãy xem xét phép nhân. Nếu bạn muốn nhân mỗi phần tử của một danh sách số với 2:

  * **Với `list`**, bạn phải dùng vòng lặp hoặc list comprehension:

    ```python
    my_list = [1, 2, 3, 4]
    doubled_list = [item * 2 for item in my_list]
    # Kết quả: [2, 4, 6, 8]
    ```

    Nếu bạn thực hiện `my_list * 2`, Python sẽ chỉ tạo ra một bản sao của `list` đó: `[1, 2, 3, 4, 1, 2, 3, 4]`.

  * **Với NumPy `array`**, bạn có thể thực hiện phép nhân trực tiếp (vectorized operation):

    ```python
    import numpy as np
    my_array = np.array([1, 2, 3, 4])
    doubled_array = my_array * 2
    # Kết quả: array([2, 4, 6, 8])
    ```

    Phép toán này không chỉ ngắn gọn hơn mà còn nhanh hơn rất nhiều khi xử lý hàng triệu phần tử.

### "Trạm trung chuyển" cho hệ sinh thái khoa học dữ liệu

NumPy là nền tảng cốt lõi cho gần như toàn bộ hệ sinh thái khoa học dữ liệu và học máy trong Python. `ndarray` của NumPy được sử dụng làm kiểu dữ liệu trung gian tiêu chuẩn để trao đổi dữ liệu giữa các thư viện khác nhau như:

  * **Pandas**: Thư viện phân tích dữ liệu mạnh mẽ này được xây dựng trên nền tảng NumPy.
  * **Matplotlib/Seaborn**: Các thư viện trực quan hóa dữ liệu này chấp nhận `ndarray` của NumPy làm đầu vào để vẽ biểu đồ.
  * **Scikit-learn**: Thư viện học máy phổ biến nhất sử dụng NumPy `array` cho dữ liệu đầu vào và các phép tính toán thuật toán.
  * **TensorFlow & PyTorch**: Các framework học sâu hàng đầu này tích hợp chặt chẽ với NumPy, cho phép chuyển đổi dễ dàng giữa các `tensor` của chúng và `ndarray` của NumPy.

Việc thành thạo NumPy giúp bạn làm việc liền mạch và hiệu quả hơn với tất cả các công cụ này.

### Biểu diễn Tensor và dữ liệu đa chiều hiệu quả

Trong học máy và các lĩnh vực khoa học khác, chúng ta thường xuyên làm việc với dữ liệu đa chiều, hay còn gọi là **tensor**. Một vector là tensor 1 chiều, một ma trận là tensor 2 chiều, và cứ thế tiếp tục.

  * **Python cơ bản**: Việc biểu diễn một ma trận hoặc một tensor 3 chiều bằng các `list` lồng nhau (`list` of `list` of `list`) trở nên rất cồng kềnh và khó quản lý. Việc truy cập các phần tử và thực hiện các phép toán trên các cấu trúc này vừa phức tạp vừa không hiệu quả.
  * **NumPy**: NumPy được thiết kế để xử lý dữ liệu đa chiều một cách tự nhiên và dễ dàng. Bạn có thể tạo ra các mảng 2D, 3D, hoặc nD và thực hiện các phép toán phức tạp (như nhân ma trận, tính toán thống kê theo các trục) một cách cực kỳ đơn giản và hiệu quả.

Nói cách khác, NumPy không chỉ bao quát được khả năng của `list` mà còn mở rộng ra một không gian tính toán số học và dữ liệu đa chiều mà Python cơ bản không thể đáp ứng tốt.

### Hệ thống hàm toán học và thống kê phong phú
NumPy không chỉ cung cấp cấu trúc dữ liệu ndarray, nó còn đi kèm với một thư viện khổng lồ các hàm toán học được tối ưu hóa.

Thống kê cơ bản: `np.mean()`, `np.median()`, `np.std()` (độ lệch chuẩn), `np.var()` (phương sai), `np.sum()`, `np.min()`, `np.max()`. Các hàm này có thể tính toán trên toàn bộ mảng hoặc theo một trục (axis) cụ thể, cực kỳ hữu ích khi bạn muốn tính giá trị trung bình của từng cột trong một ma trận.

Đại số tuyến tính: Module `np.linalg` cung cấp các hàm thiết yếu như `np.dot()` (tích vô hướng/nhân ma trận), `np.linalg.inv()` (nghịch đảo ma trận), `np.linalg.eig()` (trị riêng và vector riêng), `np.linalg.solve()` (giải hệ phương trình tuyến tính). Đây là nền tảng cho rất nhiều thuật toán học máy.

Tạo dữ liệu: Các hàm như `np.arange()`, `np.linspace()`, `np.random.rand()`, `np.random.randn()` giúp tạo ra các mảng dữ liệu mẫu để thử nghiệm thuật toán một cách nhanh chóng.
## Giới thiệu về NumPy
NumPy là gì?
![Numpy](/static/images/blogs/anya.png)
[NumPy](https://numpy.org/)
, viết tắt của Numerical Python, là một thư viện mã nguồn mở và là nền tảng cơ bản cho tính toán khoa học trong Python. Nó cung cấp một đối tượng mảng đa chiều (n-dimensional array) mạnh mẽ có tên là ndarray, cùng với một tập hợp lớn các hàm toán học phức tạp để xử lý các mảng này một cách hiệu quả. Mục tiêu chính của NumPy là cung cấp một công cụ cho phép thực hiện các phép toán số học với tốc độ cao, tương đương với các ngôn ngữ biên dịch như C hay Fortran, ngay trong môi trường linh hoạt của Python.

## Numpy cơ bản

NumPy là một thư viện mạnh mẽ trong Python, cung cấp các công cụ cần thiết để làm việc với dữ liệu số học và đa chiều. Trong phần này, chúng ta sẽ tìm hiểu các khái niệm cơ bản của NumPy, từ cấu trúc dữ liệu cốt lõi đến các thao tác thường dùng.

### Khái niệm ndarray, shape, dtype

- **ndarray**: Đây là đối tượng mảng đa chiều (n-dimensional array) của NumPy, là nền tảng cho hầu hết các thao tác trong thư viện này. Một `ndarray` có thể biểu diễn vector (1D), ma trận (2D), hoặc các mảng nhiều chiều hơn (3D, 4D,...). Không giống như `list` của Python, `ndarray` yêu cầu tất cả các phần tử có cùng kiểu dữ liệu, giúp tối ưu hóa hiệu suất tính toán.
- **shape**: Thuộc tính `shape` của một `ndarray` cho biết kích thước của mảng theo từng chiều. Ví dụ, một mảng 2D có `shape` là `(3, 4)` nghĩa là mảng có 3 hàng và 4 cột.
- **dtype**: Thuộc tính `dtype` xác định kiểu dữ liệu của các phần tử trong mảng, ví dụ: `int32`, `float64`, `complex128`. NumPy hỗ trợ nhiều kiểu dữ liệu với độ chính xác khác nhau, giúp tiết kiệm bộ nhớ và tăng tốc độ tính toán.

### Khái niệm tensor
- **tensor**: Tensor là một khái niệm bên toán học và vật lý, tensor là một đối tượng toán học
- Ở đây, để dễ hiểu hơn tensor là một cách gọi chung cho các mảng đa chiều. Một số vô hướng (Scalar) có thể coi là tensor bậc 0, Một vector là tensor 1 chiều, ma trận là tensor 2 chiều, và các mảng 3 chiều trở lên cũng được gọi là tensor.
![mô tả tensor dễ hiểu](/static/images/blogs/tensor1.png)
- Nhiều khi chúng ta học đến thời điểm hiện tại thì tự nghĩ: à! hóa ra từ xưa đến giờ hồi còn học từ nhỏ đến đại học hóa ra mình đang học về tensor chẳng qua chỉ là phiên bản nhỏ hơn 
![mô tả tensor dễ hiểu](/static/images/blogs/tensor.png)

### Khái niệm axis

- **axis**: Trong NumPy, "axis" (trục) là một khái niệm quan trọng dùng để chỉ các chiều của một mảng đa chiều (`ndarray`). Mỗi chiều của mảng được gán một số nguyên đại diện cho trục tương ứng. Ví dụ, trong một mảng 2D (ma trận), `axis=0` thường đại diện cho các hàng, và `axis=1` đại diện cho các cột. Với mảng 3D, `axis=0` có thể đại diện cho chiều sâu, `axis=1` cho hàng, và `axis=2` cho cột.
![mô tả tensor dễ hiểu](/static/images/blogs/axis3.png)

- **Vai trò trong các phép toán**: "Axis" được sử dụng để chỉ định chiều mà các hàm NumPy sẽ thực hiện tính toán. Ví dụ, khi sử dụng `np.sum()` hoặc `np.mean()`, bạn có thể chỉ định `axis` để tính tổng hoặc trung bình theo một chiều cụ thể. Điều này rất hữu ích khi làm việc với dữ liệu đa chiều, vì nó cho phép bạn kiểm soát hướng tính toán mà không cần viết vòng lặp phức tạp.
- **Ví dụ minh họa**:
  - Với mảng 2D, giả sử bạn có một ma trận điểm số của học sinh, bạn có thể tính điểm trung bình của từng học sinh bằng cách sử dụng `np.mean(scores, axis=1)` (tính trung bình theo hàng), hoặc điểm trung bình của từng môn học bằng `np.mean(scores, axis=0)` (tính trung bình theo cột).
  - Với mảng 3D, chẳng hạn như dữ liệu nhiệt độ trong không gian 3 chiều, bạn có thể tính nhiệt độ trung bình theo chiều sâu bằng `np.mean(temperature, axis=0)`.
- **Hình ảnh minh họa**: Hình ảnh dưới đây giúp bạn hình dung cách các trục được định nghĩa trong một tensor đa chiều. Mỗi trục được đánh số và đại diện cho một chiều cụ thể của dữ liệu, giúp bạn dễ dàng xác định hướng tính toán khi làm việc với các hàm NumPy.
![mô tả tensor dễ hiểu](/static/images/blogs/axis1.png)
- **Ứng dụng thực tế**: Khái niệm "axis" rất quan trọng trong AI và Machine Learning, đặc biệt khi xử lý dữ liệu ảnh hoặc tensor trọng số trong mạng nơ-ron. Ví dụ, khi làm việc với ảnh RGB (tensor 3D), bạn có thể sử dụng `axis` để thao tác trên một kênh màu cụ thể (như kênh Đỏ, Xanh lá, hoặc Xanh dương) mà không ảnh hưởng đến các kênh khác.


### Tạo mảng: np.array, np.zeros, np.ones, np.arange, np.linspace

NumPy cung cấp nhiều cách để tạo mảng với các giá trị khởi tạo khác nhau:

- **np.array()**: Tạo mảng từ dữ liệu có sẵn, ví dụ từ một `list` hoặc `tuple`.
- **np.zeros()**: Tạo mảng chứa toàn số 0 với kích thước được chỉ định.
- **np.ones()**: Tạo mảng chứa toàn số 1 với kích thước được chỉ định.
- **np.arange()**: Tạo mảng với các giá trị tăng dần trong một khoảng, tương tự `range()` của Python.
- **np.linspace()**: Tạo mảng với các giá trị cách đều nhau trong một khoảng.

Ví dụ:

```python
import numpy as np

# Tạo mảng từ list
arr1 = np.array([1, 2, 3, 4])
print("np.array:", arr1)
# Kết quả: array([1, 2, 3, 4])

# Tạo mảng toàn số 0
arr2 = np.zeros((2, 3))
print("np.zeros:\n", arr2)
# Kết quả:
# array([[0., 0., 0.],
#        [0., 0., 0.]])

# Tạo mảng toàn số 1
arr3 = np.ones((2, 2))
print("np.ones:\n", arr3)
# Kết quả:
# array([[1., 1.],
#        [1., 1.]])

# Tạo mảng với khoảng giá trị tăng dần
arr4 = np.arange(0, 10, 2)  # Từ 0 đến 10, bước nhảy 2
print("np.arange:", arr4)
# Kết quả: array([0, 2, 4, 6, 8])

# Tạo mảng với các giá trị cách đều
arr5 = np.linspace(0, 1, 5)  # 5 giá trị từ 0 đến 1
print("np.linspace:", arr5)
# Kết quả: array([0.  , 0.25, 0.5 , 0.75, 1.  ])
```

### Truy cập, slicing, broadcasting

- **Truy cập phần tử**: Bạn có thể truy cập các phần tử trong mảng bằng chỉ số (index), tương tự như `list`. Với mảng đa chiều, chỉ số được chỉ định cho từng chiều.
- **Slicing**: NumPy hỗ trợ cắt mảng (slicing) để lấy một phần của mảng, sử dụng cú pháp `[start:end:step]`.
- **Broadcasting**: Đây là một tính năng mạnh mẽ của NumPy, cho phép thực hiện các phép toán trên toàn bộ mảng mà không cần vòng lặp. Broadcasting tự động mở rộng kích thước của mảng nhỏ hơn để khớp với mảng lớn hơn trong phép toán.

Ví dụ:

```python
import numpy as np

# Tạo mảng 2D
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Truy cập phần tử
print("Phần tử tại (1, 2):", arr[1, 2])  # Kết quả: 6

# Slicing
print("Cắt hàng đầu tiên:", arr[0, :])  # Kết quả: array([1, 2, 3])
print("Cắt cột thứ hai:", arr[:, 1])    # Kết quả: array([2, 5])

# Broadcasting
arr_broadcast = arr + 10  # Cộng 10 vào từng phần tử
print("Broadcasting:\n", arr_broadcast)
# Kết quả:
# array([[11, 12, 13],
#        [14, 15, 16]])
```

### Các phép toán trên mảng

NumPy hỗ trợ nhiều phép toán số học và toán học trên mảng, được thực hiện theo từng phần tử (element-wise) hoặc trên toàn bộ mảng:

- Các phép toán cơ bản: `+`, `-`, `*`, `/`, `**` (lũy thừa).
- Các hàm toán học: `np.sin()`, `np.cos()`, `np.exp()`, `np.log()`, v.v.
- Các phép toán thống kê: `np.sum()`, `np.mean()`, `np.max()`, `np.min()`, v.v.

Ví dụ:

```python
import numpy as np

arr = np.array([1, 2, 3, 4])

# Phép toán cơ bản
print("Cộng 5:", arr + 5)
# Kết quả: array([6, 7, 8, 9])
print("Nhân 2:", arr * 2)
# Kết quả: array([2, 4, 6, 8])

# Hàm toán học
print("Sin:", np.sin(arr))
# Kết quả: array([0.84147098, 0.90929743, 0.14112001, -0.7568025 ])
print("Log:", np.log(arr))
# Kết quả: array([0.        , 0.69314718, 1.09861229, 1.38629436])

# Thống kê
print("Tổng:", np.sum(arr))
# Kết quả: 10
print("Trung bình:", np.mean(arr))
# Kết quả: 2.5
```

### Xử lý dữ liệu 2D/3D: Ma trận, reshape, transpose

NumPy rất mạnh mẽ trong việc xử lý dữ liệu đa chiều, đặc biệt là ma trận (2D) và tensor (3D trở lên):

- **Ma trận**: Bạn có thể thực hiện các phép toán ma trận như nhân ma trận (`np.dot()`), tính định thức, nghịch đảo, v.v.
- **reshape**: Thay đổi hình dạng của mảng mà không thay đổi dữ liệu bên trong.
- **transpose**: Chuyển vị ma trận (hoán đổi hàng và cột).

Ví dụ:

```python
import numpy as np

# Tạo mảng 2D (ma trận)
matrix = np.array([[1, 2], [3, 4]])
print("Ma trận ban đầu:\n", matrix)
# Kết quả:
# array([[1, 2],
#        [3, 4]])

# Nhân ma trận
matrix2 = np.array([[5, 6], [7, 8]])
product = np.dot(matrix, matrix2)
print("Nhân ma trận:\n", product)
# Kết quả:
# array([[19, 22],
#        [43, 50]])

# Reshape
arr = np.array([1, 2, 3, 4, 5, 6])
reshaped = arr.reshape(2, 3)
print("Reshape thành 2x3:\n", reshaped)
# Kết quả:
# array([[1, 2, 3],
#        [4, 5, 6]])

# Transpose
transposed = matrix.T
print("Chuyển vị:\n", transposed)
# Kết quả:
# array([[1, 3],
#        [2, 4]])
```

### Ví dụ thực tế với code

Hãy xem một ví dụ thực tế về việc sử dụng NumPy để xử lý dữ liệu ảnh đơn giản. Giả sử chúng ta có một ảnh grayscale được biểu diễn dưới dạng ma trận 2D, và chúng ta muốn tăng độ sáng của ảnh bằng cách cộng thêm một giá trị vào tất cả các pixel (bản chất khi muốn tăng độ sáng của ảnh là làm cho pixel của ảnh đó tăng lên cụ thể là gần 255 và xa 0 vì thế muốn chỗ nào sáng chỉ cần tăng giá trị pixel lên dùng cộng hoặc phép tính nào đó miễn sao không vượt quá 255), trong trường hợp dưới đây giả sử chúng ta muốn tăng độ sáng của toàn bộ ảnh nên cộng thêm 50 vào tất cả các pixel.

```python
import numpy as np

# Giả lập một ảnh grayscale 5x5 (giá trị pixel từ 0 đến 255)
image = np.array([
    [100, 120, 140, 160, 180],
    [110, 130, 150, 170, 190],
    [120, 140, 160, 180, 200],
    [130, 150, 170, 190, 210],
    [140, 160, 180, 200, 220]
])

# Tăng độ sáng bằng cách cộng thêm 50 vào tất cả các pixel
brightened_image = image + 50

# Đảm bảo giá trị pixel không vượt quá 255 (cần hàm này nếu bạn cộng giá trị mà vẫn đảm bảo pixel đó không vượt quá 255 và nhỏ hơn 0 vì vậy có thể bỏ dòng này)
brightened_image = np.clip(brightened_image, 0, 255)

print("Ảnh gốc:\n", image)
# Kết quả:
# array([[100, 120, 140, 160, 180],
#        [110, 130, 150, 170, 190],
#        [120, 140, 160, 180, 200],
#        [130, 150, 170, 190, 210],
#        [140, 160, 180, 200, 220]])

print("Ảnh sau khi tăng độ sáng:\n", brightened_image)
# Kết quả:
# array([[150, 170, 190, 210, 230],
#        [160, 180, 200, 220, 240],
#        [170, 190, 210, 230, 250],
#        [180, 200, 220, 240, 255],
#        [190, 210, 230, 250, 255]])
```

Ví dụ này minh họa cách NumPy có thể xử lý dữ liệu 2D một cách hiệu quả mặc dù chưa thể show ảnh lên cho bạn xem nhưng bản chất là như thế, áp dụng các phép toán trên toàn bộ mảng mà không cần vòng lặp. Điều này rất hữu ích trong xử lý ảnh, một lĩnh vực quan trọng của AI và Machine Learning.

#### Tập trung vào dữ liệu 2D: Xử lý ma trận và ứng dụng thực tế

Dữ liệu 2D, thường được biểu diễn dưới dạng ma trận, là một trong những cấu trúc quan trọng nhất trong tính toán khoa học và học máy. Ma trận có thể biểu diễn nhiều loại dữ liệu như bảng số liệu, ảnh grayscale, hoặc các ma trận trọng số trong mạng nơ-ron. NumPy cung cấp các công cụ mạnh mẽ để thao tác với dữ liệu 2D một cách dễ dàng.

**Ví dụ 1: Tính toán điểm trung bình của học sinh**

Giả sử bạn có một bảng điểm của 4 học sinh trong 3 môn học (Toán, Lý, Hóa) được biểu diễn dưới dạng ma trận 2D. Bạn muốn tính điểm trung bình của từng học sinh và từng môn học.

```python
import numpy as np

# Ma trận điểm của 4 học sinh trong 3 môn học
scores = np.array([
    [8.5, 7.0, 9.0],  # Học sinh 1
    [6.5, 8.0, 7.5],  # Học sinh 2
    [9.0, 8.5, 8.0],  # Học sinh 3
    [7.0, 6.5, 7.5]   # Học sinh 4
])

# Tính điểm trung bình của từng học sinh (theo hàng, axis=1)
avg_student = np.mean(scores, axis=1)
print("Điểm trung bình của từng học sinh:", avg_student)
# Kết quả: array([8.16666667, 7.33333333, 8.5       , 7.        ])

# Tính điểm trung bình của từng môn học (theo cột, axis=0)
avg_subject = np.mean(scores, axis=0)
print("Điểm trung bình của từng môn học:", avg_subject)
# Kết quả: array([7.75, 7.5 , 8.  ])
```

Kết quả sẽ cho bạn điểm trung bình của từng học sinh và từng môn học mà không cần viết vòng lặp phức tạp. Thuộc tính `axis` trong các hàm như `np.mean()` cho phép bạn chỉ định chiều tính toán, rất hữu ích khi làm việc với dữ liệu 2D.

**Ví dụ 2: Biến đổi ảnh grayscale**

Ngoài việc tăng độ sáng như ví dụ trước, bạn có thể thực hiện các biến đổi khác trên ảnh grayscale, chẳng hạn như cắt một phần của ảnh hoặc áp dụng ngưỡng (threshold) để tạo ảnh nhị phân.

```python
import numpy as np

# Giả lập một ảnh grayscale 6x6
image = np.array([
    [100, 120, 140, 160, 180, 200],
    [110, 130, 150, 170, 190, 210],
    [120, 140, 160, 180, 200, 220],
    [130, 150, 170, 190, 210, 230],
    [140, 160, 180, 200, 220, 240],
    [150, 170, 190, 210, 230, 250]
])

# Cắt một phần ảnh (chỉ lấy vùng 3x3 ở giữa)
cropped_image = image[1:4, 1:4]
print("Phần ảnh được cắt:\n", cropped_image)
# Kết quả:
# array([[130, 150, 170],
#        [140, 160, 180],
#        [150, 170, 190]])

# Áp dụng ngưỡng để tạo ảnh nhị phân (pixel > 160 thành 255, còn lại thành 0)
binary_image = np.where(image > 160, 255, 0)
print("Ảnh nhị phân:\n", binary_image)
# Kết quả:
# array([[  0,   0,   0,   0, 255, 255],
#        [  0,   0,   0, 255, 255, 255],
#        [  0,   0,   0, 255, 255, 255],
#        [  0,   0, 255, 255, 255, 255],
#        [  0,   0, 255, 255, 255, 255],
#        [  0, 255, 255, 255, 255, 255]])
```

Ví dụ này cho thấy cách NumPy có thể dễ dàng thao tác trên dữ liệu 2D để thực hiện các tác vụ như cắt ảnh hoặc biến đổi giá trị pixel, rất phổ biến trong xử lý ảnh.

#### Tập trung vào dữ liệu 3D: Tensor và ứng dụng thực tế

Dữ liệu 3D thường được sử dụng để biểu diễn các cấu trúc phức tạp hơn, chẳng hạn như ảnh màu (RGB), video (các khung hình theo thời gian), hoặc dữ liệu không gian trong mô phỏng. Trong NumPy, dữ liệu 3D được biểu diễn dưới dạng tensor 3 chiều, với các trục tương ứng với chiều cao, chiều rộng và số kênh (channels).

**Ví dụ 1: Xử lý ảnh màu RGB**

Một ảnh màu RGB được biểu diễn dưới dạng tensor 3D, trong đó mỗi pixel có 3 giá trị tương ứng với các kênh màu Đỏ (Red), Xanh lá (Green), và Xanh dương (Blue). Giả sử chúng ta có một ảnh RGB nhỏ 3x3 pixel, và chúng ta muốn tăng giá trị của kênh Đỏ lên 50.

```python
import numpy as np

# Giả lập một ảnh RGB 3x3 (3 chiều: height, width, channels)
image_rgb = np.array([
    [[255, 0, 0], [255, 255, 0], [0, 255, 0]],
    [[255, 0, 255], [128, 128, 128], [0, 0, 255]],
    [[0, 0, 0], [255, 255, 255], [100, 150, 200]]
])

# Tăng giá trị kênh Đỏ (Red) lên 50
image_rgb[:, :, 0] = image_rgb[:, :, 0] + 50

# Đảm bảo giá trị không vượt quá 255
image_rgb = np.clip(image_rgb, 0, 255)

print("Ảnh RGB sau khi tăng kênh Đỏ:\n", image_rgb)
# Kết quả:
# array([[[255,   0,   0], [255, 255,   0], [ 50, 255,   0]],
#        [[255,   0, 255], [178, 128, 128], [ 50,   0, 255]],
#        [[ 50,   0,   0], [255, 255, 255], [150, 150, 200]]])
```

Ví dụ này minh họa cách NumPy có thể thao tác trên một chiều cụ thể của tensor 3D (ở đây là kênh màu Đỏ) mà không ảnh hưởng đến các chiều khác. Điều này rất hữu ích trong xử lý ảnh màu.

**Ví dụ 2: Mô phỏng dữ liệu nhiệt độ 3D**

Giả sử bạn đang mô phỏng dữ liệu nhiệt độ trong một không gian 3D (ví dụ: một khối lập phương được chia thành các ô nhỏ). Bạn có thể sử dụng tensor 3D để biểu diễn dữ liệu này và tính toán các giá trị trung bình theo một chiều cụ thể.

```python
import numpy as np

# Giả lập dữ liệu nhiệt độ trong không gian 3x3x3 (độ C)
temperature = np.array([
    [[20, 21, 22], [23, 24, 25], [26, 27, 28]],
    [[30, 31, 32], [33, 34, 35], [36, 37, 38]],
    [[40, 41, 42], [43, 44, 45], [46, 47, 48]]
])

# Tính nhiệt độ trung bình theo chiều sâu (axis=0)
avg_depth = np.mean(temperature, axis=0)
print("Nhiệt độ trung bình theo chiều sâu:\n", avg_depth)
# Kết quả:
# array([[30., 31., 32.],
#        [33., 34., 35.],
#        [36., 37., 38.]])

# Tính nhiệt độ trung bình theo hàng (axis=1)
avg_row = np.mean(temperature, axis=1)
print("Nhiệt độ trung bình theo hàng:\n", avg_row)
# Kết quả:
# array([[23., 24., 25.],
#        [33., 34., 35.],
#        [43., 44., 45.]])
```

Ví dụ này cho thấy cách NumPy có thể xử lý dữ liệu 3D để tính toán các giá trị thống kê theo các chiều khác nhau, rất hữu ích trong các ứng dụng như mô phỏng vật lý hoặc phân tích dữ liệu không gian.



### Ứng dụng trong AI và Machine Learning
NumPy rất quan trọng trong AI và Machine Learning, đặc biệt khi xử lý dữ liệu ảnh (2D cho ảnh grayscale, 3D cho ảnh RGB) và tính toán ma trận trọng số trong huấn luyện mô hình. Nó cho phép thao tác dễ dàng trên mảng đa chiều để biến đổi ảnh như thay đổi độ sáng hay áp dụng bộ lọc.

## Tóm tắt kiến thức (Summary)
- NumPy cung cấp `ndarray` để xử lý dữ liệu đa chiều hiệu quả, cùng các hàm toán học và thống kê mạnh mẽ.
- Thành thạo NumPy giúp bạn làm việc với dữ liệu 2D/3D dễ dàng, rất quan trọng trong AI và Data Science.

## Chúc mừng bạn đã đọc xong bài viết!
![Chúc mừng bạn đã đọc xong!](/static/images/blogs/blender-anya.png)
“Trong các bài tới, mình sẽ sử dụng NumPy trong pandas, bài toán dự đoán,....”
